import { SystemDesignQuestion } from "./types";


export const systemDesignQuestions: SystemDesignQuestion[] = [
  {
    id: "url-shortener",
    shortTitle: "URL",
    title: "Design a URL Shortening Service like TinyURL",
    difficulty: "Medium",
    timeEstimate: "45-60 min",
    complexity: "Medium",
    description: [
      "Design a URL shortening service like TinyURL. This service will provide short aliases for long URLs.",
      "Your service should have the following capabilities: when a user enters a long URL, the service generates a shorter, unique URL. When users access the short URL, they should be redirected to the original long URL.",
      "Additionally, the service should collect analytics on URL usage, such as the number of times a URL has been accessed.",
    ],
    requirements: [
      "Given a long URL, generate a shorter, unique alias",
      "When users access the short URL, redirect them to the original URL",
      "Users should be able to create custom short URLs (optional)",
      "Track click statistics for each shortened URL",
      "The service should be highly available and scalable",
    ],
    constraints: [
      "The system should handle high traffic volumes",
      "URLs should not be predictable",
      "The service should have minimal latency",
      "Shortened links should not expire (or have a very long expiration time)",
    ],
    hints: [
      "Consider using a hash function to convert long URLs to short codes",
      "Think about how to handle collisions in your hashing algorithm",
      "A database will be needed to store the mapping between short and long URLs",
      "Consider using a distributed cache to improve read performance",
      "For analytics, you might want to use a separate database or a time-series database",
    ],
    solution: {
      approach: [
        "The core of a URL shortening service is a mapping between the short URL and the original long URL. We can use a hash function to generate a short code from the long URL, but we need to ensure uniqueness.",
        "One approach is to use a counter-based system where each URL gets assigned an incremental ID, which is then encoded into a short string (using base62 encoding for example).",
        "For high availability and scalability, we can use a distributed database with sharding based on the short URL key. A cache layer (like Redis) in front of the database can significantly improve read performance.",
      ],
      components: [
        "API Gateway: Handles incoming requests for URL shortening and redirection",
        "Application Servers: Process the business logic for URL shortening and analytics",
        "Database: Stores the mapping between short and long URLs",
        "Cache: Improves read performance for frequently accessed URLs",
        "Analytics Service: Collects and processes usage statistics",
      ],
      considerations: [
        "Security: Prevent abuse of the service for malicious URLs",
        "Rate limiting: Protect against DoS attacks",
        "Database partitioning: Consider sharding strategies for the database",
        "Cache eviction policy: Determine how to manage the cache size",
        "Analytics storage: Consider time-series databases for efficient analytics queries",
      ],
    },
  },
  {
    id: "chat-app",
    shortTitle: "Chat",
    title: "Design a Real-time Chat Application",
    difficulty: "Hard",
    timeEstimate: "60-75 min",
    complexity: "High",
    description: [
      "Design a real-time chat application similar to WhatsApp or Facebook Messenger that allows users to send messages to individuals or groups.",
      "The application should support features like message delivery status, online/offline status, and message history. It should also be able to handle media attachments like images and videos.",
    ],
    requirements: [
      "Support one-on-one messaging between users",
      "Support group messaging with multiple participants",
      "Show message delivery status (sent, delivered, read)",
      "Display online/offline status of users",
      "Store message history for users to access later",
      "Support media attachments (images, videos, files)",
      "Push notifications for new messages",
    ],
    constraints: [
      "The system should be able to handle millions of concurrent users",
      "Messages should be delivered with minimal latency",
      "The system should be reliable with no message loss",
      "Users should be able to access their message history from any device",
    ],
    hints: [
      "Consider using WebSockets or a similar technology for real-time communication",
      "Think about how to handle offline users and message delivery",
      "A distributed message queue might be useful for handling high volumes of messages",
      "Consider how to efficiently store and retrieve message history",
      "Think about encryption for securing messages",
    ],
    solution: {
      approach: [
        "A real-time chat application requires a bidirectional communication channel between clients and servers. WebSockets are ideal for this purpose as they provide a persistent connection.",
        "For scalability, we can use a microservices architecture where different services handle specific functions like message delivery, user presence, and media storage.",
        "To handle millions of concurrent connections, we need a distributed system with load balancing and service discovery.",
      ],
      components: [
        "Chat Service: Handles message routing and delivery",
        "Presence Service: Tracks online/offline status of users",
        "Media Service: Manages storage and delivery of media attachments",
        "Notification Service: Sends push notifications to offline users",
        "Database Cluster: Stores user data, message history, and metadata",
        "Cache Layer: Improves performance for frequently accessed data",
        "Load Balancers: Distribute traffic across multiple servers",
      ],
      considerations: [
        "Message ordering: Ensure messages are displayed in the correct order",
        "Offline message delivery: Store messages for offline users",
        "End-to-end encryption: Protect message content from unauthorized access",
        "Database partitioning: Shard data based on user or conversation ID",
        "Media storage optimization: Compress and resize images/videos",
        "Connection management: Handle reconnections and network changes",
      ],
    },
  },
  {
    id: "netflix",
    shortTitle: "Netflix",
    title: "Design a Video Streaming Platform like Netflix",
    difficulty: "Hard",
    timeEstimate: "75-90 min",
    complexity: "High",
    description: [
      "Design a video streaming platform similar to Netflix that allows users to watch videos on demand. The platform should support features like video recommendations, search, and user profiles.",
      "The system should be able to stream videos to millions of users concurrently with minimal buffering and high quality. It should also adapt to different network conditions and device capabilities.",
    ],
    requirements: [
      "Stream videos to users with minimal buffering",
      "Support different video qualities based on network conditions",
      "Provide personalized video recommendations",
      "Allow users to search for videos by title, genre, actor, etc.",
      "Support multiple user profiles under a single account",
      "Track viewing history and allow users to continue watching from where they left off",
      "Support multiple devices (web, mobile, smart TVs)",
    ],
    constraints: [
      "The system should handle millions of concurrent streams",
      "Videos should start playing with minimal delay",
      "The system should be highly available and fault-tolerant",
      "Content delivery should be optimized for different regions",
    ],
    hints: [
      "Consider using a Content Delivery Network (CDN) for efficient video delivery",
      "Think about how to encode videos for different qualities and devices",
      "A recommendation system will require data processing and machine learning",
      "Consider how to handle user authentication and session management across devices",
    ],
  },
  {
    id: "twitter",
    shortTitle: "Twitter",
    title: "Design a Social Media Platform like Twitter",
    difficulty: "Hard",
    timeEstimate: "60-75 min",
    complexity: "High",
    description: [
      "Design a social media platform similar to Twitter where users can post short messages (tweets), follow other users, and see a timeline of tweets from users they follow.",
      "The platform should support features like hashtags, mentions, retweets, and likes. It should also be able to handle a high volume of tweets and user interactions.",
    ],
    requirements: [
      "Users can post tweets (short messages up to 280 characters)",
      "Users can follow other users",
      "Users see a timeline of tweets from users they follow",
      "Support for hashtags, mentions, retweets, and likes",
      "Search functionality for tweets and users",
      "Trending topics based on tweet volume and engagement",
    ],
    constraints: [
      "The system should handle a high volume of tweets (thousands per second)",
      "Timelines should load quickly",
      "The system should be highly available and scalable",
      "Search results should be relevant and up-to-date",
    ],
    hints: [
      "Consider how to efficiently store and retrieve tweets",
      "Think about how to generate user timelines (fan-out)",
      "A distributed cache can improve performance for frequently accessed data",
      "Consider using a message queue for asynchronous processing of tweets",
    ],
  },
  {
    id: "uber",
    shortTitle: "Uber",
    title: "Design a Ride-Sharing Service like Uber",
    difficulty: "Hard",
    timeEstimate: "75-90 min",
    complexity: "High",
    description: [
      "Design a ride-sharing service similar to Uber or Lyft that connects riders with drivers. The service should match riders with nearby drivers, calculate fares, and track ride progress.",
      "The system should handle real-time location updates, efficient matching algorithms, and payment processing.",
    ],
    requirements: [
      "Riders can request rides from their current location to a destination",
      "The system matches riders with nearby available drivers",
      "Drivers can accept or decline ride requests",
      "The system tracks the real-time location of drivers and riders",
      "Calculate estimated arrival times and fares",
      "Process payments after rides are completed",
      "Allow riders and drivers to rate each other",
    ],
    constraints: [
      "The system should handle thousands of ride requests per minute",
      "Location updates should be processed in real-time",
      "Matching should be efficient and minimize wait times for riders",
      "The system should be highly available and fault-tolerant",
    ],
    hints: [
      "Consider using a geospatial database or index for efficient location-based queries",
      "Think about how to handle surge pricing during high demand",
      "Real-time communication between riders and drivers is important",
      "Consider how to handle payment processing securely",
    ],
  },
]

